---
layout: post
title: Improving OCR Inputs from OCR Outputs?
date: 2013-02-14 15:32:00.000000000 -06:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- hackathon
- presentations
tags:
- ocr
meta:
  blogger_blog: manuscripttranscription.blogspot.com
  blogger_author: Ben W. Brumfield
  blogger_permalink: "/2013/02/improving-ocr-inputs-from-ocr-outputs.html"
  blogger_internal: "/feeds/5730930067468816440/posts/default/8413741380955571419"
  _edit_last: '10'
  _genesis_scripts_body_position: bottom
  _yoast_wpseo_content_score: '60'
  _yoast_wpseo_estimated-reading-time-minutes: '13'
  _yoast_wpseo_meta-robots-noindex: '1'
  _yoast_wpseo_meta-robots-nofollow: '1'
author:
  login: benwbrum
  email: benwbrum@gmail.com
  display_name: Ben Brumfield
  first_name: Ben
  last_name: Brumfield
permalink: "/improving-ocr-inputs-from-ocr-outputs/"
---
<p>This is a transcript of my talk at the <a href="https://www.idigbio.org/wiki/index.php/IConference_2013_iDigBio_AOCR_WG_Wiki">iDigBio Augmenting OCR Hackathon</a>, presenting preliminary results of my efforts before the event.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-Sk1_ud5Sm5k/URz8vupvm8I/AAAAAAAAAi8/-QvKR7DSmlw/s1600/HackathonPresentation+-+01.jpg"><img title="" src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+01.jpg" width="320" height="239" border="0" /></a></div>
<p>For my preliminary work, I tried to improve the inputs to our OCR process through looking at the outputs of a naive OCR.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-zELTfJgfG4U/URz8vlRNaNI/AAAAAAAAAi0/pF5a2g8PFvo/s1600/HackathonPresentation+-+02.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+02.jpg" width="320" height="239" border="0" /></a></div>
<p>One of the first things that we can do to improve the quality of our inputs to OCR is to not feed them handwriting.  To quote Homer Simpson, "Remember son, if you don't try, you can't fail."  So let's not try feeding our OCR processes handwritten materials.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://3.bp.blogspot.com/-NVqW703Kbgo/URz8vie72VI/AAAAAAAAAi4/f7q0Qlnlkoo/s1600/HackathonPresentation+-+03.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+03.jpg" width="320" height="239" border="0" /></a></div>
<p>To do this, we need to try to detect the presence of handwriting.  When you try to feed handwriting to OCR, you get a lot of gibberish.  If we can detect handwriting, we can route some of our material to "humans in the loop" -- not wasting their time with things we could be OCRing.  So how do we do this?</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://3.bp.blogspot.com/-aDRuN7yudaY/URz8wK8SE3I/AAAAAAAAAjA/nJtKXHwOMYA/s1600/HackathonPresentation+-+04.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+04.jpg" width="320" height="239" border="0" /></a></div>
<p>My approach was to use the outputs of [naive] OCR to detect the gibberish it produces when it sees handwriting to try to determine when there was handwriting present in the images.  The first thing I did before I started programming, was classifying OCR output from the lichen samples by visual inspection: whether I thought there was hand writing present or not, based on looking at the OCR outputs.  Step two was to automate the classifications.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-MMlIWVCarlw/URz8wMLVhkI/AAAAAAAAAjM/NbLMu9ktnYQ/s1600/HackathonPresentation+-+05.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+05.jpg" width="320" height="239" border="0" /></a></div>
<p>I tried this initially on the results that came out of ABBY and then the results that came out of Tesseract, and I was really surprised by how hard it was for me as a human to spot gibberish.  I could spot it, but in a lot of cases -- ABBY does a great job of cleaning up its OCR output -- so in a lot of cases, particularly the labels that were all printed with the exception of some species name that was handwritten, ABBY generally misses those.  Tesseract, on the other hand, does not produce outputs that are quite as clean.</p>
<p>So the really interesting thing about this to me is that while we were able to get 70-75% accuracy on both ABBY and Tesseract, if you look at the difference between the false positives that come out of ABBY and Tesseract and the false negatives, I think there is some real potential here for making a much more sophisticated algorithm.  Maybe the goal is to pump things through ABBY for OCR, but beforehand look at Tesseract output to determine whether there is handwriting or not.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-w2f1W3DurAI/URz8wYYm3cI/AAAAAAAAAjE/SwcBIBhcsNo/s1600/HackathonPresentation+-+06.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+06.jpg" width="320" height="239" border="0" /></a></div>
<p>The next thing I did was try to automate this.  I just used some regular expressions to look for representative gibberish, and then based on the number of matches got results that matched the visual inspection, though you do get some false positives.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-iBu0mT3ScRU/URz8whCcA4I/AAAAAAAAAjI/vDNnpFzpErg/s1600/HackathonPresentation+-+07.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+07.jpg" width="320" height="239" border="0" /></a></div>
<p>The next thing I want to do with this is to come up with a way to filter the results based on doing a detection on ABBY [output] and doing a detection on Tesseract [output].</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-_b429XTiHVA/URz8w_NlEPI/AAAAAAAAAjQ/Gk493rnzJgc/s1600/HackathonPresentation+-+08.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+08.jpg" width="320" height="239" border="0" /></a></div>
<p>The next thing that I wanted to work on was label extraction.</p>
<p>We're all familiar with the entomology labels and problems associated with them.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://3.bp.blogspot.com/-Kygc6ZH8AbE/URz8xPU_TEI/AAAAAAAAAjg/-76lboCZF8Q/s1600/HackathonPresentation+-+09.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+09.jpg" width="320" height="239" border="0" /></a></div>
<p>So if you pump that image of <i>Cerceris</i> through Tesseract, you end up with a lot of garbage. You end up with a lot of gibberish, a lot of blank lines, some recognizable words.  That "Cerceris compacta" is, I believe, the result of a post-digitzation process: it looks like an artifact of somebody using Photoshop or ImageMagick to add labels to the image.  The rest of it is the actual label contents, and it's pretty horrible.  We've all stared at this; we've all seen it.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-z-DurWlq-4k/URz8xCfrjmI/AAAAAAAAAjc/YX56f10VsQ4/s1600/HackathonPresentation+-+10.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+10.jpg" width="320" height="239" border="0" /></a></div>
<p>So how do you sort the labels in these images from rulers, holes in styrofoam, and bugs?  I tried a couple of approaches.  I first tried to traverse the image itself, looking for  contrast differences between the more-or-less white labels and their backgrounds.  The problem I found with that was that the highest contrast regions of the image are the difference between print and the labels behind the print.  So you're looking for a fairly low-contrast difference--and there are shadows involved.  Probably, if I had more math I could do this, but this was too hard.</p>
<p>So my second try was to use the output of OCR that produces these word bounding boxes to determine where labels might be, because labels have words on them.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-UfaX_0HxFD8/URz8xf2rSPI/AAAAAAAAAjY/Kk40eeSYtm8/s1600/HackathonPresentation+-+11.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+11.jpg" width="320" height="239" border="0" /></a></div>
<p>If you run Tesseract or Ocropus with an "hocr" option, you get these pseudo-HTML files that have bounding boxes around the text.  Here you see this text element inside a span; the span has these HTML attributes that say "this is an OCR word".  Most importantly, you have the title attribute as the bounding box definition of a rectangle.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://3.bp.blogspot.com/-opK46w_pvHA/URz8x9-Sv7I/AAAAAAAAAjo/U9lwWBkcocc/s1600/HackathonPresentation+-+12.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+12.jpg" width="320" height="239" border="0" /></a></div>
<p>If you extract that and re-apply it to an image, you see that there are a lot of rectangles on the image, but not all the rectangles are words.  You've got bees, you've got rulers; you've got a lot of random trash in the styrofoam.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-YSyi1njD2F4/URz8yIOUdII/AAAAAAAAAjw/oNdQt6zwHF0/s1600/HackathonPresentation+-+13.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+13.jpg" width="320" height="239" border="0" /></a></div>
<p>So how do we sort good rectangles from bad rectangles?  First I did a pass looking at the OCR text itself.  If the bounding box was around text that looked like a word, I decided that this was a good rectangle.  Next, I did a pass by size.  A lot of the dots in the stryofoam come out looking suspiciously word-like for reasons I don't understand.  So if the area of the rectangle was smaller than .015% of the image, I threw it away.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://3.bp.blogspot.com/-mrm-6-xuqa4/URz8yNoMOLI/AAAAAAAAAj0/YVQTOfHEmYQ/s1600/HackathonPresentation+-+14.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+14.jpg" width="320" height="239" border="0" /></a></div>
<p>The result was [above]: you see rectangles marked with green that pass my filter and rectangles marked with red that don't.  So you get rid of the bee, you get rid of part of the ruler -- more important, you get rid of a lot of the trash over here. [Pointing to small red rectangles on styrofoam.] There are some bugs in this--we end up getting rid of "Arizona" for reasons I need to look at--but it does clean the thing up pretty nicely.</p>
<p><i>Question:</i> A very simple solution to this would be for the guys at Berkeley to take two photographs -- one of the bee and ruler, one of the labels.  I'm just thinking how much simpler that would be.</p>
<p><i>Me:</i> If the guys in Berkeley had a workflow that took the picture--even with the bee--agaist a black background, that would trivialize this problem completely!</p>
<p><i>Question:</i> If the photos were taken against a background of wallpaper with random letters, it couldn't be much worse than this [styrofoam].  The idea is that you could make this a lot easier if you would go to the museums and say, we'll participate, we'll do your OCRing, but you must take photographs this way.</p>
<p><i>Me:</i> You're absolutely right.  You could even hand them a piece of cardboard that was a particular color and say, "Use this and we'll do it for you, don't use it and we won't."  I completly agree.  But this is what we're starting with, so this is what I'm working on.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-o3CcCwIhjnM/URz8yRM3D1I/AAAAAAAAAj8/pc5mmgBLO2k/s1600/HackathonPresentation+-+15.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+15.jpg" width="320" height="239" border="0" /></a></div>
<p>The next thing is to aggregate all those word boxes into the labels [they constitute]. For each rectangle, look at all of the other rectangles in the system, expand them both a little bit, determine if they overlap, and if they do, consolidate them into a new rectangle, and repeat the process until there are no more consolidations to be done. <i>[Thanks to Sara Brumfield for this algorithm.]</i></p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-Oif2nY6ndYE/URz8ygytdgI/AAAAAAAAAkE/VezUnKzuZdA/s1600/HackathonPresentation+-+16.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+16.jpg" width="320" height="239" border="0" /></a></div>
<p>If you do that, the blue boxes are the consolidated rectangles.  Here you see a rectangle around the U.C. Berkeley label, a rectangle around the collector, and a pretty glorious rectangle around the determination that does not include the border.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://3.bp.blogspot.com/-F1RD8W1_B04/URz8y06m-VI/AAAAAAAAAkA/84pG5nyKoOA/s1600/HackathonPresentation+-+17.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+17.jpg" width="320" height="239" border="0" /></a></div>
<p>Having done that, you want to further filter those rectangles.  Labels contain words, so you can reject any rectangles that were "primitives" -- you can get rid of the ruler rectangle, for example, because it was just a single [primitive] rectangle that was pretty large.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-RcKK07OJjc4/URz8zKTCibI/AAAAAAAAAkM/YLSCTJ_A9gI/s1600/HackathonPresentation+-+18.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+18.jpg" width="320" height="239" border="0" /></a></div>
<p>So you make sure that all of your rectangles were created through consolidation, then you crop the results.  And you end up automatically extracting these images from that sample -- some of which are pretty good, some of which are not.  We've got some extra trash here, we cropped the top of "Arizona" here.  But for some of the labels -- I don't think I could do better than that determination label by hand.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-o5iZI1Qo99k/URz8zMFAAqI/AAAAAAAAAkI/WHBXDtPcPv8/s1600/HackathonPresentation+-+19.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+19.jpg" width="320" height="239" border="0" /></a></div>
<p>Then you feed the results back into Tesseract one by one, then we combine the text files in Y-axis order to produce a single file for all those images.  (Not something that's a necessary step, but that does allow us to compare the results with the "raw" OCR.)  How did we do?</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-dYiLSY-HSl8/URz8zgEK2bI/AAAAAAAAAkY/UVdXww83aLQ/s1600/HackathonPresentation+-+20.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+20.jpg" width="320" height="239" border="0" /></a></div>
<p>This is a resulting text file -- we've got a date that's pretty recognizable, we've got a label that's recognizable, and the determination is pretty nice.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-1quej69m-LY/URz8zvtmKqI/AAAAAAAAAkU/l9psSkMIUkE/s1600/HackathonPresentation+-+21.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+21.jpg" width="320" height="239" border="0" /></a></div>
<p>Let's compare it to the raw result.  In the cropped results, we somehow missed the "Cerceris compacta", we did a much nicer job on the date, and the determination is actually pretty nice.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-ef_UAF8-qPw/URz8zsn1WeI/AAAAAAAAAkg/Feaw0yIrMD0/s1600/HackathonPresentation+-+22.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+22.jpg" width="320" height="239" border="0" /></a></div>
<p>Let's try it on a different specimen image.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-sNAVDp_DSAU/URz8z7xccGI/AAAAAAAAAkc/bHtcSWqUoeM/s1600/HackathonPresentation+-+23.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+23.jpg" width="320" height="239" border="0" /></a></div>
<p>We run the same process over this <i>Stigmus</i> image.  We again find labels pretty well.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-l_pdD96TFsM/URz80AcP82I/AAAAAAAAAkk/tFA40m10etA/s1600/HackathonPresentation+-+24.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+24.jpg" width="320" height="239" border="0" /></a></div>
<p>When we crop them out, the autocrop pulls them out into these three images.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://1.bp.blogspot.com/-UiD8Y27Q3as/URz803t0zeI/AAAAAAAAAk8/8CmOkV0RBBI/s1600/HackathonPresentation+-+26.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+26.jpg" width="320" height="239" border="0" /></a></div>
<p>Running those images through OCR, we get a comparison of the original, which had a whole lot of gibberish.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-0vfGrUAgn7o/URz800_XRtI/AAAAAAAAAk0/iImjQJdtAyY/s1600/HackathonPresentation+-+27.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+27.jpg" width="320" height="239" border="0" /></a></div>
<p>The original did a decent job with the specimen number, but the autocrop version does as well.  In particular, for this location [field], the autocrop version is nearly perfect, whereas the original is just a mess.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://4.bp.blogspot.com/-U-hxXcbPu9A/URz80-17tUI/AAAAAAAAAk4/CRzshzUn7XM/s1600/HackathonPresentation+-+28.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+28.jpg" width="320" height="239" border="0" /></a></div>
<p>My conclusion is that we can extract labels fairly effectly by first doing a naive pass of OCR and looking at the results of that, and that the results of OCR over the cropped images is less horrible than running OCR over the raw images -- though still not great.</p>
<div style="clear: both; text-align: center;"><a style="margin-left: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/-UsyyG_9wOd4/URz81aQX8aI/AAAAAAAAAlA/QyEpOtalwJU/s1600/HackathonPresentation+-+29.jpg"><img src="{{ site.baseurl }}/assets/2013/02/HackathonPresentation+-+29.jpg" width="320" height="239" border="0" /></a></div>
<p><i>[2013-02-15 update: See <a href="http://manuscripttranscription.blogspot.com/2013/02/results-of-ocrocrop-approach-to.html">the results of this approach</a> and <a href="http://manuscripttranscription.blogspot.com/2013/02/idigbio-augmenting-ocr-hackathon.html">my write-up</a> of the iDigBio Augmenting OCR Hackathon itself.]</i></p>
